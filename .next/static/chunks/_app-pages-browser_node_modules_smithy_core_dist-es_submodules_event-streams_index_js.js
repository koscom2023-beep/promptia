"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_smithy_core_dist-es_submodules_event-streams_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventStreamSerde: function() { return /* binding */ EventStreamSerde; }\n/* harmony export */ });\n/* harmony import */ var _smithy_util_utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @smithy/util-utf8 */ \"(app-pages-browser)/./node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js\");\n/* harmony import */ var _smithy_util_utf8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @smithy/util-utf8 */ \"(app-pages-browser)/./node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js\");\n\nclass EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? _smithy_util_utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? _smithy_util_utf8__WEBPACK_IMPORTED_MODULE_1__.fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac21pdGh5L2NvcmUvZGlzdC1lcy9zdWJtb2R1bGVzL2V2ZW50LXN0cmVhbXMvRXZlbnRTdHJlYW1TZXJkZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlFQUF5RTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBDQUEwQztBQUNuRiwyQ0FBMkMsZ0NBQWdDO0FBQzNFLDJDQUEyQywyQ0FBMkM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixpRUFBaUU7QUFDckY7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FLG1DQUFtQyxnQ0FBZ0M7QUFDbkUsbUNBQW1DLHlFQUF5RTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUMscURBQXFEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UscURBQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1REFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzbWl0aHkvY29yZS9kaXN0LWVzL3N1Ym1vZHVsZXMvZXZlbnQtc3RyZWFtcy9FdmVudFN0cmVhbVNlcmRlLmpzPzFjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJvbVV0ZjgsIHRvVXRmOCB9IGZyb20gXCJAc21pdGh5L3V0aWwtdXRmOFwiO1xuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtU2VyZGUge1xuICAgIG1hcnNoYWxsZXI7XG4gICAgc2VyaWFsaXplcjtcbiAgICBkZXNlcmlhbGl6ZXI7XG4gICAgc2VyZGVDb250ZXh0O1xuICAgIGRlZmF1bHRDb250ZW50VHlwZTtcbiAgICBjb25zdHJ1Y3Rvcih7IG1hcnNoYWxsZXIsIHNlcmlhbGl6ZXIsIGRlc2VyaWFsaXplciwgc2VyZGVDb250ZXh0LCBkZWZhdWx0Q29udGVudFR5cGUsIH0pIHtcbiAgICAgICAgdGhpcy5tYXJzaGFsbGVyID0gbWFyc2hhbGxlcjtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuc2VyZGVDb250ZXh0ID0gc2VyZGVDb250ZXh0O1xuICAgICAgICB0aGlzLmRlZmF1bHRDb250ZW50VHlwZSA9IGRlZmF1bHRDb250ZW50VHlwZTtcbiAgICB9XG4gICAgYXN5bmMgc2VyaWFsaXplRXZlbnRTdHJlYW0oeyBldmVudFN0cmVhbSwgcmVxdWVzdFNjaGVtYSwgaW5pdGlhbFJlcXVlc3QsIH0pIHtcbiAgICAgICAgY29uc3QgbWFyc2hhbGxlciA9IHRoaXMubWFyc2hhbGxlcjtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJlYW1NZW1iZXIgPSByZXF1ZXN0U2NoZW1hLmdldEV2ZW50U3RyZWFtTWVtYmVyKCk7XG4gICAgICAgIGNvbnN0IHVuaW9uU2NoZW1hID0gcmVxdWVzdFNjaGVtYS5nZXRNZW1iZXJTY2hlbWEoZXZlbnRTdHJlYW1NZW1iZXIpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gdGhpcy5zZXJpYWxpemVyO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29udGVudFR5cGUgPSB0aGlzLmRlZmF1bHRDb250ZW50VHlwZTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFJlcXVlc3RNYXJrZXIgPSBTeW1ib2woXCJpbml0aWFsUmVxdWVzdE1hcmtlclwiKTtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJlYW1JdGVyYWJsZSA9IHtcbiAgICAgICAgICAgIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI6ZXZlbnQtdHlwZVwiOiB7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBcImluaXRpYWwtcmVxdWVzdFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjptZXNzYWdlLXR5cGVcIjogeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogXCJldmVudFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjpjb250ZW50LXR5cGVcIjogeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogZGVmYXVsdENvbnRlbnRUeXBlIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZXIud3JpdGUocmVxdWVzdFNjaGVtYSwgaW5pdGlhbFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gc2VyaWFsaXplci5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbFJlcXVlc3RNYXJrZXJdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGFnZSBvZiBldmVudFN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBwYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXJzaGFsbGVyLnNlcmlhbGl6ZShldmVudFN0cmVhbUl0ZXJhYmxlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudFtpbml0aWFsUmVxdWVzdE1hcmtlcl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBldmVudC5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBldmVudC5ib2R5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbk1lbWJlciA9IE9iamVjdC5rZXlzKGV2ZW50KS5maW5kKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICE9PSBcIl9fdHlwZVwiO1xuICAgICAgICAgICAgfSkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkaXRpb25hbEhlYWRlcnMsIGJvZHksIGV2ZW50VHlwZSwgZXhwbGljaXRQYXlsb2FkQ29udGVudFR5cGUgfSA9IHRoaXMud3JpdGVFdmVudEJvZHkodW5pb25NZW1iZXIsIHVuaW9uU2NoZW1hLCBldmVudCk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIFwiOmV2ZW50LXR5cGVcIjogeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogZXZlbnRUeXBlIH0sXG4gICAgICAgICAgICAgICAgXCI6bWVzc2FnZS10eXBlXCI6IHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IFwiZXZlbnRcIiB9LFxuICAgICAgICAgICAgICAgIFwiOmNvbnRlbnQtdHlwZVwiOiB7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBleHBsaWNpdFBheWxvYWRDb250ZW50VHlwZSA/PyBkZWZhdWx0Q29udGVudFR5cGUgfSxcbiAgICAgICAgICAgICAgICAuLi5hZGRpdGlvbmFsSGVhZGVycyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkZXNlcmlhbGl6ZUV2ZW50U3RyZWFtKHsgcmVzcG9uc2UsIHJlc3BvbnNlU2NoZW1hLCBpbml0aWFsUmVzcG9uc2VDb250YWluZXIsIH0pIHtcbiAgICAgICAgY29uc3QgbWFyc2hhbGxlciA9IHRoaXMubWFyc2hhbGxlcjtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJlYW1NZW1iZXIgPSByZXNwb25zZVNjaGVtYS5nZXRFdmVudFN0cmVhbU1lbWJlcigpO1xuICAgICAgICBjb25zdCB1bmlvblNjaGVtYSA9IHJlc3BvbnNlU2NoZW1hLmdldE1lbWJlclNjaGVtYShldmVudFN0cmVhbU1lbWJlcik7XG4gICAgICAgIGNvbnN0IG1lbWJlclNjaGVtYXMgPSB1bmlvblNjaGVtYS5nZXRNZW1iZXJTY2hlbWFzKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZU1hcmtlciA9IFN5bWJvbChcImluaXRpYWxSZXNwb25zZU1hcmtlclwiKTtcbiAgICAgICAgY29uc3QgYXN5bmNJdGVyYWJsZSA9IG1hcnNoYWxsZXIuZGVzZXJpYWxpemUocmVzcG9uc2UuYm9keSwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbk1lbWJlciA9IE9iamVjdC5rZXlzKGV2ZW50KS5maW5kKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICE9PSBcIl9fdHlwZVwiO1xuICAgICAgICAgICAgfSkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBldmVudFt1bmlvbk1lbWJlcl0uYm9keTtcbiAgICAgICAgICAgIGlmICh1bmlvbk1lbWJlciA9PT0gXCJpbml0aWFsLXJlc3BvbnNlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhT2JqZWN0ID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZXIucmVhZChyZXNwb25zZVNjaGVtYSwgYm9keSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFPYmplY3RbZXZlbnRTdHJlYW1NZW1iZXJdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIFtpbml0aWFsUmVzcG9uc2VNYXJrZXJdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAuLi5kYXRhT2JqZWN0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmlvbk1lbWJlciBpbiBtZW1iZXJTY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRTdHJlYW1TY2hlbWEgPSBtZW1iZXJTY2hlbWFzW3VuaW9uTWVtYmVyXTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRTdHJlYW1TY2hlbWEuaXNTdHJ1Y3RTY2hlbWEoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0JpbmRpbmdzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIG1lbWJlcl0gb2YgZXZlbnRTdHJlYW1TY2hlbWEuc3RydWN0SXRlcmF0b3IoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBldmVudEhlYWRlciwgZXZlbnRQYXlsb2FkIH0gPSBtZW1iZXIuZ2V0TWVyZ2VkVHJhaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNCaW5kaW5ncyA9IGhhc0JpbmRpbmdzIHx8IEJvb2xlYW4oZXZlbnRIZWFkZXIgfHwgZXZlbnRQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLmlzQmxvYlNjaGVtYSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlci5pc1N0cmluZ1NjaGVtYSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9ICh0aGlzLnNlcmRlQ29udGV4dD8udXRmOEVuY29kZXIgPz8gdG9VdGY4KShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVtYmVyLmlzU3RydWN0U2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W25hbWVdID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZXIucmVhZChtZW1iZXIsIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudFt1bmlvbk1lbWJlcl0uaGVhZGVyc1tuYW1lXT8udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5pc051bWVyaWNTY2hlbWEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImJ5dGVzXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSBCaWdJbnQodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0JpbmRpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt1bmlvbk1lbWJlcl06IG91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgW3VuaW9uTWVtYmVyXTogYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZXIucmVhZChldmVudFN0cmVhbVNjaGVtYSwgYm9keSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICR1bmtub3duOiBldmVudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXN5bmNJdGVyYXRvciA9IGFzeW5jSXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0RXZlbnQgPSBhd2FpdCBhc3luY0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGZpcnN0RXZlbnQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jSXRlcmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0RXZlbnQudmFsdWU/Lltpbml0aWFsUmVzcG9uc2VNYXJrZXJdKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQHNtaXRoeTo6Y29yZS9wcm90b2NvbHMgLSBpbml0aWFsLXJlc3BvbnNlIGV2ZW50IGVuY291bnRlcmVkIGluIGV2ZW50IHN0cmVhbSBidXQgbm8gcmVzcG9uc2Ugc2NoZW1hIGdpdmVuLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpcnN0RXZlbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFJlc3BvbnNlQ29udGFpbmVyW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdEV2ZW50Py52YWx1ZT8uW2luaXRpYWxSZXNwb25zZU1hcmtlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZmlyc3RFdmVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgYXN5bmNJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZUV2ZW50Qm9keSh1bmlvbk1lbWJlciwgdW5pb25TY2hlbWEsIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSB0aGlzLnNlcmlhbGl6ZXI7XG4gICAgICAgIGxldCBldmVudFR5cGUgPSB1bmlvbk1lbWJlcjtcbiAgICAgICAgbGV0IGV4cGxpY2l0UGF5bG9hZE1lbWJlciA9IG51bGw7XG4gICAgICAgIGxldCBleHBsaWNpdFBheWxvYWRDb250ZW50VHlwZTtcbiAgICAgICAgY29uc3QgaXNLbm93blNjaGVtYSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSB1bmlvblNjaGVtYS5nZXRTY2hlbWEoKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RbNF0uaW5jbHVkZXModW5pb25NZW1iZXIpO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsSGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAoIWlzS25vd25TY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSBldmVudFt1bmlvbk1lbWJlcl07XG4gICAgICAgICAgICBldmVudFR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgc2VyaWFsaXplci53cml0ZSgxNSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRTY2hlbWEgPSB1bmlvblNjaGVtYS5nZXRNZW1iZXJTY2hlbWEodW5pb25NZW1iZXIpO1xuICAgICAgICAgICAgaWYgKGV2ZW50U2NoZW1hLmlzU3RydWN0U2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFttZW1iZXJOYW1lLCBtZW1iZXJTY2hlbWFdIG9mIGV2ZW50U2NoZW1hLnN0cnVjdEl0ZXJhdG9yKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBldmVudEhlYWRlciwgZXZlbnRQYXlsb2FkIH0gPSBtZW1iZXJTY2hlbWEuZ2V0TWVyZ2VkVHJhaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0UGF5bG9hZE1lbWJlciA9IG1lbWJlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnRbdW5pb25NZW1iZXJdW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImJpbmFyeVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlclNjaGVtYS5pc051bWVyaWNTY2hlbWEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoLTIpICoqIDMxIDw9IHZhbHVlICYmIHZhbHVlIDw9IDIgKiogMzEgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImludGVnZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImxvbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZW1iZXJTY2hlbWEuaXNUaW1lc3RhbXBTY2hlbWEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcInRpbWVzdGFtcFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVtYmVyU2NoZW1hLmlzU3RyaW5nU2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlclNjaGVtYS5pc0Jvb2xlYW5TY2hlbWEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImJvb2xlYW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEhlYWRlcnNbbWVtYmVyTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50W3VuaW9uTWVtYmVyXVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRQYXlsb2FkTWVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWRTY2hlbWEgPSBldmVudFNjaGVtYS5nZXRNZW1iZXJTY2hlbWEoZXhwbGljaXRQYXlsb2FkTWVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWRTY2hlbWEuaXNCbG9iU2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0UGF5bG9hZENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkU2NoZW1hLmlzU3RyaW5nU2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0UGF5bG9hZENvbnRlbnRUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplci53cml0ZShwYXlsb2FkU2NoZW1hLCBldmVudFt1bmlvbk1lbWJlcl1bZXhwbGljaXRQYXlsb2FkTWVtYmVyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVyLndyaXRlKGV2ZW50U2NoZW1hLCBldmVudFt1bmlvbk1lbWJlcl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBzbWl0aHkvY29yZS9ldmVudC1zdHJlYW1zIC0gbm9uLXN0cnVjdCBtZW1iZXIgbm90IHN1cHBvcnRlZCBpbiBldmVudCBzdHJlYW0gdW5pb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VTZXJpYWxpemF0aW9uID0gc2VyaWFsaXplci5mbHVzaCgpO1xuICAgICAgICBjb25zdCBib2R5ID0gdHlwZW9mIG1lc3NhZ2VTZXJpYWxpemF0aW9uID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/ICh0aGlzLnNlcmRlQ29udGV4dD8udXRmOERlY29kZXIgPz8gZnJvbVV0ZjgpKG1lc3NhZ2VTZXJpYWxpemF0aW9uKVxuICAgICAgICAgICAgOiBtZXNzYWdlU2VyaWFsaXphdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBldmVudFR5cGUsXG4gICAgICAgICAgICBleHBsaWNpdFBheWxvYWRDb250ZW50VHlwZSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@smithy/core/dist-es/submodules/event-streams/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@smithy/core/dist-es/submodules/event-streams/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventStreamSerde: function() { return /* reexport safe */ _EventStreamSerde__WEBPACK_IMPORTED_MODULE_0__.EventStreamSerde; }\n/* harmony export */ });\n/* harmony import */ var _EventStreamSerde__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventStreamSerde */ \"(app-pages-browser)/./node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac21pdGh5L2NvcmUvZGlzdC1lcy9zdWJtb2R1bGVzL2V2ZW50LXN0cmVhbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzbWl0aHkvY29yZS9kaXN0LWVzL3N1Ym1vZHVsZXMvZXZlbnQtc3RyZWFtcy9pbmRleC5qcz9jODFhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL0V2ZW50U3RyZWFtU2VyZGVcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@smithy/core/dist-es/submodules/event-streams/index.js\n"));

/***/ })

}]);